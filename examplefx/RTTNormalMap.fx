//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Simple diffuse bump
//
// To demonstrate the usage of normal maps generated by the Render To Texture tool.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

float4x4 WorldXf : World;
float4x4 WvpXf : WorldViewProj;
float4x4 WorldITXf : WorldInverseTranspose;
float4x4 ViewIXf : ViewInverse;

//////////////////// Tweakables ////////////////////

float4 ambientColor : Ambient
<
	string UIName = "Ambient Color";
> = { 0.1, 0.1, 0.1, 1.0 };

texture diffuseTexture : DiffuseMap
<
	string name = "seafloor.dds";
	string UIName = "Diffuse Map";
	int Texcoord = 0;
	int MapChannel = 1;
>;

sampler2D diffuseSampler = sampler_state
{
	Texture = <diffuseTexture>;
	MinFilter = Linear;
	MagFilter = Linear;
	MipFilter = Linear;
	ADDRESSU = WRAP;
	ADDRESSV = WRAP;
};

float bumpScale
<
	string UIName = "Bump Scale";
	string UIType = "FloatSpinner";
	float UIMin = 0.0f;
	float UIMax = 3.0f;
> = { 1.0 };

bool flipRed
<
	string UIName = "Flip Red (X)";
> = false;

bool flipGreen
<
	string UIName = "Flip Green (Y)";
> = false;

bool swapRG
<
	string UIName = "Swap Red and Green";
> = false;

// Orthogonalize tangent and bitangent on each pixel, otherwise use the interpolated values.
// This parameter is controlled by 3ds Max according to the "Tangents and Bitangents" preference.
bool orthogonalizeTangentBitangentPerPixel
<
	string UIName = "Orthogonalize per Pixel (Set by 3ds Max)";
> = false;

texture tangentMap : NormalMap
<
	string name = "NMP_Ripples2_512.dds";
	string UIName = "Tangent Space";
	int Texcoord = 0;
	int MapChannel = 1;
>;

sampler2D tangentSampler = sampler_state
{
	Texture = <tangentMap>;
	MinFilter = Linear;
	MagFilter = Linear;
	MipFilter = Linear;
	ADDRESSU = WRAP;
	ADDRESSV = WRAP;
};

texture worldMap : NormalMap
< 
	string UIName = "World Space";
	int Texcoord = 0;
	int MapChannel = 1;
>;

sampler2D worldSampler = sampler_state 
{
	Texture = <worldMap>;
	MinFilter = Linear;
	MagFilter = Linear;
	MipFilter = Linear;
	ADDRESSU = WRAP;
	ADDRESSV = WRAP;
};

texture localMap : NormalMap
< 
	string UIName = "Local Space";
	int Texcoord = 0;
	int MapChannel = 1;
>;

sampler2D localSampler = sampler_state 
{
	Texture = <localMap>;
	MinFilter = Linear;
	MagFilter = Linear;
	MipFilter = Linear;
	ADDRESSU = WRAP;
	ADDRESSV = WRAP;
};

texture screenMap : NormalMap
< 
	string UIName = "Screen Space";
	int Texcoord = 0;
	int MapChannel = 1;
>;

sampler2D screenSampler = sampler_state 
{
	Texture = <screenMap>;
	MinFilter = Linear;
	MagFilter = Linear;
	MipFilter = Linear;
	ADDRESSU = WRAP;
	ADDRESSV = WRAP;
};

float3 lightPos : Position
<
	string Object = "PointLight";
	string Space = "World";
> = { -50, -50, 50 };

struct a2v
{
	float4 Position : POSITION;
	float3 Normal : NORMAL;
	float2 UV : TEXCOORD0;
	float3 T : TANGENT;
	float3 B : BINORMAL;
};

struct v2f
{
	float4 Position : POSITION; // in projection space
	float2 UV : TEXCOORD0;
	float3 LightVector : TEXCOORD1;
	float3 WorldNormal : TEXCOORD2;
	float3 WorldTangent : TEXCOORD3;
	float3 WorldBinormal : TEXCOORD4;
};

v2f DiffuseBumpVS(a2v IN)
{
	v2f OUT;

	OUT.Position = mul(IN.Position, WvpXf);
	OUT.UV = IN.UV;

	float3 Pw = mul(IN.Position, WorldXf).xyz;
	OUT.LightVector = lightPos - Pw;

	OUT.WorldNormal = mul(float4(IN.Normal, 0), WorldITXf).xyz;
	OUT.WorldTangent = mul(float4(IN.T, 0), WorldITXf).xyz;
	OUT.WorldBinormal = mul(float4(IN.B, 0), WorldITXf).xyz;

	return OUT;
}

float3 SampleNormalMap(sampler2D normalMap, float2 uv)
{
	float3 bumpNormal = 2.0f * (tex2D(normalMap, uv).rgb - 0.5f);

	// Reorder
	if (flipRed) bumpNormal.r = -bumpNormal.r;
	if (flipGreen) bumpNormal.g = -bumpNormal.g;
	if (swapRG) bumpNormal.rg = bumpNormal.gr;

#ifdef MAX_NITROUS 
	// Flip green value because by default green means -y in the normal map generated by 3ds Max.
	bumpNormal.g = -bumpNormal.g;
#endif
	return bumpNormal;
}

void ApplyBumpScale(float3 Nn, inout float3 bumpNormal)
{
	float3 perturb = bumpNormal - Nn;
	perturb *= bumpScale;
	bumpNormal = normalize(Nn + perturb);
}

float4 ComputeColor(float2 uv, float3 normal, float3 lightVec)
{
	float4 diffuseColor = tex2D(diffuseSampler, uv);
	float diffContrib = dot(normal, normalize(lightVec));
	float4 result = diffuseColor * diffContrib + ambientColor;
	result.a = 1.0;
	return result;
}

float4 DiffuseBumpPS_Tangent(v2f IN) : COLOR
{
	float3 bumpNormal = SampleNormalMap(tangentSampler, IN.UV);

	// Convert bump normal from tangent space to world space
	float3 Nn = normalize(IN.WorldNormal);
	float3 Tn = normalize(IN.WorldTangent);
	float3 Bn = normalize(IN.WorldBinormal);

	if (orthogonalizeTangentBitangentPerPixel)
	{
		float3 bitangent = normalize(cross(Nn, Tn));
		Tn = normalize(cross(bitangent, Nn));
		// Bitangent need to be flipped if the map face is flipped. We don't have map face handedness in shader so make
		// the calculated bitangent point in the same direction as the interpolated bitangent which has considered the flip.
		Bn = sign(dot(bitangent, Bn)) * bitangent;
	}

	bumpNormal = normalize(bumpNormal.x * Tn + bumpNormal.y * Bn + bumpNormal.z * Nn);

	ApplyBumpScale(Nn, bumpNormal);

	return ComputeColor(IN.UV, bumpNormal, IN.LightVector);
}

float4 DiffuseBumpPS_World(v2f IN) : COLOR
{
	float3 bumpNormal = SampleNormalMap(worldSampler, IN.UV);

	// The bump normal is already in world space. No conversion needed.

	ApplyBumpScale(normalize(IN.WorldNormal), bumpNormal);

	return ComputeColor(IN.UV, bumpNormal, IN.LightVector);
}

float4 DiffuseBumpPS_Local(v2f IN) : COLOR
{
	float3 bumpNormal = SampleNormalMap(localSampler, IN.UV);

	// Convert bump normal from local space to world space.
	bumpNormal = mul(bumpNormal, WorldITXf);

	ApplyBumpScale(normalize(IN.WorldNormal), bumpNormal);

	return ComputeColor(IN.UV, bumpNormal, IN.LightVector);
}

float4 DiffuseBumpPS_Screen(v2f IN) : COLOR
{
	float3 bumpNormal = SampleNormalMap(screenSampler, IN.UV);

	// Convert bump normal from screen space to world space.
	bumpNormal = mul(bumpNormal, ViewIXf);

	ApplyBumpScale(normalize(IN.WorldNormal), bumpNormal);

	return ComputeColor(IN.UV, bumpNormal, IN.LightVector);
}

//////////////////// Techniques ////////////////////

technique TangentSpace
{
	pass p0
	{
		ZEnable = true;
		ZWriteEnable = true;
		CullMode = None;
		VertexShader = compile vs_1_1 DiffuseBumpVS();
		PixelShader = compile ps_2_0 DiffuseBumpPS_Tangent();
	}
}

technique WorldSpace
{
	pass p0
	{
		ZEnable = true;
		ZWriteEnable = true;
		CullMode = None;
		VertexShader = compile vs_1_1 DiffuseBumpVS();
		PixelShader = compile ps_2_0 DiffuseBumpPS_World();
	}
}

technique LocalSpace
{
	pass p0
	{
		ZEnable = true;
		ZWriteEnable = true;
		CullMode = None;
		VertexShader = compile vs_1_1 DiffuseBumpVS();
		PixelShader = compile ps_2_0 DiffuseBumpPS_Local();
	}
}

technique ScreenSpace
{
	pass p0
	{
		ZEnable = true;
		ZWriteEnable = true;
		CullMode = None;
		VertexShader = compile vs_1_1 DiffuseBumpVS();
		PixelShader = compile ps_2_0 DiffuseBumpPS_Screen();
	}
}
